{"meta":{"title":"Chronus Universe","subtitle":"","description":"","author":"Chronus","url":"http://chronus.cc","root":"/"},"posts":[{"tags":[{"name":"Linux","slug":"Linux","permalink":"http://chronus.cc/tags/Linux/"}],"title":"使用ldd以及readelf指令来了解你的库文件","date":"2021/07/01","text":"在之前的博客中，我们介绍了如何生成安卓下面可以使用的库文件，例如Boost，OpenCV之类的，但是在X64系统下，我们是无法通过ldd了解我们生成的库文件具体信息是什么，存在有哪些相关的依赖，这个使用我们就需要使用readelf这个指令来了解我们生成的这个库文件。 ELF文件和readelf指令ELF文件全称Executable and Linkable Format，是Linux系统中默认的目标文件格式，我们通常使用的静态库文件，动态库文件，目标文件都属于带类型文件格式，这种类型的具体文件组成在这里就不详细介绍了，很多Linux系统相关书籍都会提供很多详细的介绍，包括文件组织，文件头等等。 现在回到readelf这个指令，常用的使用包括如下： # 可以获得elf文件的头，我们可以通过这个判断编译出来的库文件类型的使用平台是否正确readelf -h &lt;elf&gt;# 查看自己需要的依赖readelf -a &lt;elf&gt; | grep &lt;keyword&gt; 上面两个指令可以简单完成对于库文件头的查看，以及了解其中所需要的依赖。对于查看程序头表和节头表的内容，恕我确实不常用，在这里就不介绍了。 ldd的常见使用相对于readelf，ldd的使用更为常见，在这里就简单列出一些几个常用的指令，如下： ldd &lt;target file&gt; #列出所有的链接信息，通常配合grep使用ldd -v &lt;target file&gt; #列出版本信息，如果自己电脑里安装有多个依赖版本，这个很常用，例如电脑中安装有多个OpenCVldd -u &lt;target file&gt; #获取未经直接使用的链接库，我会配合strip使用，减少库的大小ldd -d/r &lt;target file&gt; #如果有确实的依赖，进行relocation","permalink":"http://chronus.cc/2021/07/01/use-ldd-readelf-command/","photos":[]},{"tags":[{"name":"Android","slug":"Android","permalink":"http://chronus.cc/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"http://chronus.cc/tags/NDK/"}],"title":"Boost库在Android NDK环境内的编译","date":"2021/06/30","text":"在常用的库依赖中，例如opencv，glog等，由于这项目都是通过CMakeLists.txt 完成编译，只需要简单的指定NDK的编译器，使用如下的编译指令就可以完成项目的编译，生成所需要的库文件。 cd &lt;project&gt;mkdir build &amp;&amp; cd buildcmake \\ -DCMAKE_TOOLCHAIN_FILE=$NDK/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=arm64-v8a \\ -DANDROID_NATIVE_API_LEVEL=android-23 \\ -DANDROID_STL=c++_shared \\ .. 但是，与上述项目不同，Boost使用的编译工具主要是自带的bootstrap.sh，需要的编译过程则会更加复杂，在这里以1.65.0版本的Boost为例，详细介绍一下如何在Ubuntu环境内交叉编译获得32位以及64位的Boost库文件。 首先，我们需要通过Boost官方页面下载指定版本的压缩包，这里需要注意的是，因为压缩包和Github上的Boost仓库并不一致，不要下载Boost仓库并切换分支。下载完成后我们将下载的压缩包解压并切换至解压文件夹。 之后我们需要产生编译Boost所需要的toolchain文件，我们需要指定好NDK的路径，确认该变量在系统中可用，指令echo $NDK可以正常运行。然后，我们使用下面脚本完成工具链的生成。 toolchain=$PWD/toolchain# arm64-v8a$NDK/build/tools/make-standalone-toolchain.sh \\ --arch=arm64 --platform=android-23 \\ --install-dir=\"$toolchain\" \\ --toolchain=aarch64-linux-android-clang \\ --use-llvm --stl=c++_shared# armeabi-v7a$NDK/build/tools/make-standalone-toolchain.sh \\ --arch=arm --platform=android-23 \\ --install-dir=\"$toolchain\" \\ --toolchain=armeabi-linux-android-clang \\ --use-llvm --stl=c++_shared 第三步，我们需要生成编译所需要的user-config.jam文件，执行如下指令： user_config=tools/build/src/user-config.jamrm -f $user_config# arm64-v8acat &lt;&lt;EOF &gt; $user_configimport os ;using clang : android:\"$toolchain/bin/clang++\":&lt;archiver&gt;$toolchain/bin/aarch64-linux-android-ar&lt;ranlib&gt;$toolchain/bin/aarch64-linux-android-ranlib;EOF# armeabi-v7acat &lt;&lt;EOF &gt; $user_configimport os ;using clang : android:\"$toolchain/bin/clang++\":&lt;archiver&gt;$toolchain/bin/arm-linux-androideabi-ar&lt;ranlib&gt;$toolchain/bin/arm-linux-androideabi-ranlib;EOF 最后，执行常规的bootstrap.sh以及b2便可以编译生成库文件，在此过程中，我们可以指定编译库的安装路径。由于我们编译获得的是安卓上的库文件，强烈不建议安装到系统/usr/local路径下，我们可以直接编辑bootstrap.sh文件中的PREFIX变量为PWD/install。 ./bootstrap.sh --with-toolset=clang./b2 -j32 \\ --with-atomic \\ --with-chrono \\ --with-container \\ --with-date_time \\ --with-exception \\ --with-filesystem \\ --with-iostreams \\ --with-locale \\ --with-log \\ --with-program_options \\ --with-random \\ --with-regex \\ --with-serialization \\ --with-system \\ --with-test \\ --with-thread \\ --with-timer \\ --address-model=32 \\ toolset=clang-android \\ architecture=arm \\ # arm64 for arm64-v8a variant=release \\ --layout=versioned \\ target-os=android \\ threading=multi \\ threadapi=pthread \\ link=shared \\ runtime-link=shared \\ install 最后我们可以在当前路径下的install文件夹内找到所有的库文件和头文件并在安卓工程中使用它们。","permalink":"http://chronus.cc/2021/06/30/build-boost-for-android-ndk/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"http://chronus.cc/tags/Linux/"},{"name":"Hexo","slug":"Hexo","permalink":"http://chronus.cc/tags/Hexo/"}],"title":"Hexo网页搭建：打开本地端口与局域网展示","date":"2021/06/29","text":"在完成Hexo网页后，我们通常可以执行如下步骤，完成网页在本地端的预览： hexo cleanhexo ghexo s 随后便可以在任意浏览器打开http://localhost:4000/预览已经生成的网页。除此之外，我们还希望把生成的主页分享给一起的伙伴，这就需要我们将本地的端口开放给局域网使用。我们也借这个机会复习一下Linux中常用的网络指令。 # 列出所有的套接字接口# l - listening# n - with port number# t - tcp# u - udpnetstat -lntu# 尝试寻找端口号netstat -na | grep :4000# 如果有使用ubuntu firewallsudo ufw allow 4000 在上述的命令行，当使用ubuntu firewall时，ufw会管理所有的端口和连接，用来替换旧版本的iptables防火墙。而针对其他版本的Linux，可以使用如下两个指令： # centos &amp; redhatfirewall-cmd --add-port=4000/tcp# iptable # A - append添加新的规则# p - protocal协议使用TCP# --dport - 端口使用400# j - jump跳转规则为ACCEPT接受iptables -A INPUT -p tcp --dport 4000 -j ACCEPT# 重启iptablessudo systemctl restart iptables 最后通过ifconfig获得局域网ip后便可以通过ip:4000在其他的局域网主机上访问刚刚搭建的网页。","permalink":"http://chronus.cc/2021/06/29/open-local-port-to-network/","photos":[]},{"tags":[],"title":"Hello World","date":"2021/06/29","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment Highlightalert('Hello World!');","permalink":"http://chronus.cc/2021/06/29/hello-world/","photos":[]}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://chronus.cc/tags/Linux/"},{"name":"Android","slug":"Android","permalink":"http://chronus.cc/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"http://chronus.cc/tags/NDK/"},{"name":"Hexo","slug":"Hexo","permalink":"http://chronus.cc/tags/Hexo/"}]}